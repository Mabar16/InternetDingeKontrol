/*
 * generated by Xtext 2.20.0
 */
package sdu.mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.List
import java.util.HashMap
import sdu.mdsd.ioT.*
import java.util.ArrayList
import sdu.mdsd.ioT.ExpressionLeft
import sdu.mdsd.ioT.ExpressionRight
import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock
import sdu.mdsd.ioT.SENSOR
import java.util.UUID
import sdu.mdsd.ioT.Device
import sdu.mdsd.services.IoTGrammarAccess.SendCommandElements
import java.util.Map

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class IoTGenerator extends AbstractGenerator {

	Device currentDevice;
	Resource _resource

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// var model = resource.allContents.filter(Model).toList
		_resource = resource
		for (dev : resource.allContents.filter(Device).toList) {

			fsa.generateFile('''«dev.name»/main.py''', dev.convDevice)
		}
	}

	def containsLedAction(Resource resource) {
		resource.allContents.filter(LEDAction).size > 0
	}

	def getExternalOf(Device device) {
		device.eAllContents.filter(ExternalOf).toList
	}

	def dispatch convDevice(IoTDevice device) {
		currentDevice = device;
		var loopTexts = new ArrayList<CharSequence>();
		for (var i = 0; i < device.program.loops.length; i++) {
			val text = device.program.loops.get(i).convLoop(i);
			loopTexts.add(text)
		}
		var sensorInits = device.eResource.allContents.filter(SENSOR).map[convertSensorInitCode].toList

		var string = '''
			import pycom
			import time
			import _thread
			from machine import UART,ADC, Pin
			from network import WLAN
			from LTR329ALS01 import LTR329ALS01
			
			«IF (getExternalOf(device).length > 0)»
				from externals import«FOR modules : getExternalOf(device) SEPARATOR(',')» «modules.method.name»«ENDFOR»
			«ENDIF»
			
			«IF (containsLedAction(_resource))» 
				pycom.heartbeat(False)
			«ENDIF»
			
			«FOR connectionStatement : device.program.connectStatements»
				«connectionStatement.convConfigurationIoT»	
				
			«ENDFOR»
			
			«FOR v : device.program.variables»
				«v.convToPy»
			«ENDFOR»
			
			«FOR s : sensorInits»
				«s»
			«ENDFOR»
			
			def th_func(delay, action):
				while True:
					time.sleep(delay)
					action()
			
			«FOR t : loopTexts»
				«t»
			«ENDFOR»
		'''
		currentDevice = null;
		return string
	}

	def CharSequence convertSensorInitCode(SENSOR s) {
		switch (s) {
			LIGHTSENSOR: {

				'''
					integration_time = LTR329ALS01.ALS_INT_50
					measurement_rate = LTR329ALS01.ALS_RATE_50 
					gain = LTR329ALS01.ALS_GAIN_1X 
					lightsensor = LTR329ALS01(integration=integration_time, rate=measurement_rate, gain=gain)
				'''
			}
			TEMPERATURE: {
				'''
					p_out = Pin('P19', mode=Pin.OUT)
					p_out.value(1)
					adc = ADC()             # create an ADC object
					apin = adc.channel(pin='P16', attn=2)   # create an analog pin on P16
				'''
			}
		}
	}

	def convToPy(VarOrList vl) {
		switch vl {
			Variable: '''«vl.name»  = «vl.value !== null ? vl.value.convVariableValue : "None"»'''
			PyList: '''«vl.name» = []'''
		}
	}

	def String convVariableValue(Expression exp) {
		switch exp {
			BoolExpression: exp.value instanceof True ? "True" : "False"
			IntExpression: exp.value + ""
		}

	}

	def CharSequence convLoop(Loop loop, int i) {
		val seconds = convertTime(loop.timeUnit, loop.timeVal)

		return '''
			def loop«i»():
				«FOR cmd : loop.command»
					«cmd.convCMD()»
				«ENDFOR»
			
			_thread.start_new_thread(th_func, («seconds», loop«i»))
			
		'''
	}

	def convertTime(TIMEUNIT timeunit, int timevalue) {
		switch timeunit {
			MILLISECONDS: timevalue / 1000
			SECONDS: timevalue
			MINUTES: timevalue * 60
			HOURS: timevalue * 3600
			DAYS: timevalue * 24 * 3600
			WEEKS: timevalue * 7 * 24 * 3600
		}
	}

	def CharSequence convCMD(Command cmd) {

		switch cmd {
			ClearListAction: '''«cmd.list.name» = []'''
			LEDAction: '''pycom.rgbled(«cmd.state == 'ON' ? '0xFFFFFF':'0x000000'»)'''
			ArrowCommand: {

				val uuid = UUID.randomUUID.toString.replace('-', '_'); // dashes are illegal in method names in python
				'''
					def expLeft«uuid»():
						«cmd.left.convExpLeft»
					
					
					def expRight«uuid»(value):
						«cmd.right.convExpRight»
					
					
					result = expLeft«uuid»()
					expRight«uuid»(result)
				'''

			}
			IfStatement: {
				'''
					if («cmd.condition.convComparison»):
						«FOR content : cmd.commands»
							«content.convCMD»
						«ENDFOR»
					«IF (cmd.elseBlock !== null)»
						else:
							«FOR line : cmd.elseBlock.commands»
								«line.convCMD»
							«ENDFOR»
					«ENDIF»
				'''
			}
		}
	}

	def CharSequence convComparison(Comparison comp) {
		switch comp {
			AND: '''«comp.left.convComparison» and «comp.right.convComparison»'''
			EQL: '''«comp.left.convComparison» «comp.op.op» «comp.right.convComparison»'''
			ItemBool: '''«comp.value»'''
			ItemInt: '''«comp.value»'''
			ItemVariable: '''«comp.value.name»'''
			OR: '''«comp.left.convComparison» or «comp.right.convComparison»'''
		}

	}

	def convExpRight(ExpressionRight right) {
		switch (right) {
			SendCommand:
				right.target.sendToDevice
			AddToList: '''«right.list.name».append(value)'''
			ToVar: '''
				global «right.variable.name»
				«right.variable.name» = value
			'''
		}
	}

	def getSendToDevice(Device targetDevice) {

		var connectionList = this.currentDevice.program.connectStatements.filter([device == targetDevice]).toList
		var connection = connectionList.length > 0 ? connectionList.get(0) : throw new Exception(
				"A connection to the device not found")

		switch (currentDevice) {
			IoTDevice: {
				if (connection.configuration.type == "WLAN") {
					return '''socket.send(value)'''
				} else if (connection.configuration.type == "SERIAL") {
					return '''print(value)''' // print sends a value over serial USB connection on PyCom devices.
				} else {
					throw new Exception("Connect config not found")
				}
			}
			ControllerDevice: {
				if (connection.configuration.type == "WLAN") {
					return '''socket.send(value)'''
				} else if (connection.configuration.type == "SERIAL") {
					return '''serial«targetDevice.name».write(str(value) + "\n")'''
				} else {
					throw new Exception("Connect config not found")
				}
			}
		}
	}

	def convExpLeft(ExpressionLeft left) {
		switch (left) {
			ReadVariable: '''return «left.value.name»'''
			ReadSensor:
				left.sensor.getReadSensorCode
			ReadConnection: {
				left.source.readFromDevice
			}
			ExternalOf: '''return «left.method.name»(«left.target.name»)'''
			BoolExpression: '''return «left.convVariableValue»'''
			IntExpression: '''return «left.convVariableValue»'''
		}
	}

	def CharSequence readFromDevice(Device sourceDevice) {
		var connectionList = this.currentDevice.program.connectStatements.filter([device == sourceDevice]).toList
		var connection = connectionList.length > 0 ? connectionList.get(0) : throw new Exception(
				"A connection to the device not found")
		switch (currentDevice) {
			IoTDevice: {
				if (connection.configuration.type == "WLAN") {
					return '''return socket.recv(1024)'''
				} else if (connection.configuration.type == "SERIAL") {
					return '''return uart.readall()'''
				} else {
					throw new Exception("Connect config not found")
				}
			}
			ControllerDevice: {
				if (connection.configuration.type == "WLAN") {
					return '''return socket.recv(1024)'''
				} else if (connection.configuration.type == "SERIAL") {
					return '''return serial«sourceDevice.name».readline()'''
				} else {
					throw new Exception("Connect config not found")
				}
			}
		}
	}

	def getGetReadSensorCode(SENSOR sensor) {
		switch (sensor) {
			LIGHTSENSOR: '''
				luxTuple = lightsensor.light()
				lux = (luxTuple[0]+luxTuple[1])/2
				return lux
			'''
			TEMPERATURE: '''
				temperature = apin()
				return temperature
			'''
		}
	}

	def dispatch convDevice(ControllerDevice device) {
		currentDevice = device;
		var loopTexts = new ArrayList<CharSequence>();
		for (var i = 0; i < device.program.loops.length; i++) {
			val text = device.program.loops.get(i).convLoop(i);
			loopTexts.add(text)
		}
		var string = '''
			import serial
			import time
			import _thread
			
			
			# Initializer
			
			«IF (getExternalOf(device).length > 0)»
				from externals import «FOR modules : getExternalOf(device) SEPARATOR(',')» «modules.method.name» «ENDFOR»
			«ENDIF»
			
			«FOR connectionStatement : device.program.connectStatements»
				«connectionStatement.convConfigurationController»
			«ENDFOR»
			
			«FOR v : device.program.variables»
				«v.convToPy»
			«ENDFOR»
			
			def th_func(delay, action):
				while True:
					time.sleep(delay)
					action()
						
			«FOR t : loopTexts»
				«t»
			«ENDFOR»
			
			# Do nothing forever, because the thread(s) started above would exit if this (main) thread exits.
			while True:
				time.sleep(100)
		'''
		currentDevice = null;
		return string
	}

	def String convConfigurationIoT(ConnectStatement statement) {
		var configuration = statement.configuration
		switch configuration.type {
			case 'WLAN': {
				val map = getWlanIotValues(configuration.declarations)
				'''
					SSID = '«map.get('ssid')»'
					KEY = '«map.get('password')»'
					
					wlan = WLAN(mode=WLAN.STA)
					nets = wlan.scan()
					for net in nets:
						if net.ssid == SSID:
							print('Network found!')
							wlan.connect(net.ssid, auth=(net.sec, KEY), timeout=5000)
							while not wlan.isconnected():
								machine.idle() # save power while waiting
							print('WLAN connection succeeded!')
							print(wlan.ifconfig()) # Print the connection settings, IP, Subnet mask, Gateway, DNS
							break
				'''
			}
			case 'SERIAL': {
				var map = getSerialIotValues(configuration.declarations)
				'''
					uart = UART(«statement.address.value»)
					uart.init(«map.get('baudrate')», bits=«map.get('bits')», parity=«map.get('parity')», stop=«map.get('stopbit')»)
				'''
			}
		}
	}

	def String convConfigurationController(ConnectStatement statement) {
		var map = getSerialControllerValues(statement.configuration.declarations)
		switch statement.configuration.type {
			case 'SERIAL': {
				'''
					serial«statement.device.name»= serial.Serial(
					    port='«statement.address.value»',
					    baudrate=«map.get('baudrate')»,
					    parity=«map.get('parity')»,
					    stopbits=«map.get('stopbit')»,
					    bytesize=«map.get('bytesize')»
					)
				'''
			}
			default: {
				''''''
			}
		}
	}

	def extractDeclaration(List<Declaration> declarations, String _key) {
		val d = declarations.filter[key == _key]
		d.length > 0 ? d.get(0) : null
	}

	def getSerialControllerValues(List<Declaration> declarations) {
		val baudrate = declarations.extractDeclaration('baudrate')?.value
		val stopbit = declarations.extractDeclaration('stopbit')?.value
		val bytesize = declarations.extractDeclaration('bytesize')?.value
		val parity = declarations.extractDeclaration('parity')?.value
		val convertedParity = parity.convertParityToPy

		var map = new HashMap<String, String>()
		// Serial
		map.put('baudrate', baudrate ?: '115200')
		map.put('stopbit', stopbit ?: '1')
		map.put('bytesize', bytesize ?: '8')
		map.put('parity', convertedParity ?: 'serial.PARITY_NONE')
		map
	}
	
	def String convertParityToPy(String parity) {
		
		switch(parity){
			case '0', case 'None':  'serial.PARITY_NONE'
			case 'even' : "serial.PARITY_EVEN"
			case "odd": "serial.PARITY_ODD"
			case "mark" :  "serial.PARITY_MARK"
			case "space": "serial.PARITY_SPACE"
			default: null
			
		}
	}

	def getSerialIotValues(List<Declaration> declarations) {
		val baudrate = declarations.extractDeclaration('baudrate')?.value
		val stopbit = declarations.extractDeclaration('stopbit')?.value
		val bits = declarations.extractDeclaration('bits')?.value
		val parity = declarations.extractDeclaration('parity')?.value
		val bus = declarations.extractDeclaration('bus')?.value

		var map = new HashMap<String, String>()
		// Serial
		map.put('baudrate', baudrate ?: '115200')
		map.put('stopbit', stopbit ?: '1')
		map.put('bits', bits ?: '8')
		map.put('parity', parity ?: 'None')
		map
	}

	def getWlanIotValues(List<Declaration> declarations) {
		val ssid = declarations.extractDeclaration('ssid')?.value
		val password = declarations.extractDeclaration('password')?.value

		var map = new HashMap<String, String>()
		// Serial
		map.put('ssid', ssid ?: 'INPUT SSID')
		map.put('password', password ?: 'INPUT PASSWORD')
		map
	}

}
