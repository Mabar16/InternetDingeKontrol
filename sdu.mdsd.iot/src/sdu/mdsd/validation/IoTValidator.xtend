/*
 * generated by Xtext 2.20.0
 */
package sdu.mdsd.validation


import org.eclipse.xtext.validation.Check
import sdu.mdsd.ioT.Device
import javax.inject.Inject
import sdu.mdsd.ioT.IoTPackage
import sdu.mdsd.ioT.IoTDevice
import sdu.mdsd.ioT.Program
import sdu.mdsd.ioT.ControllerDevice
import com.google.common.collect.HashMultimap
import sdu.mdsd.ioT.Model
import sdu.mdsd.ioT.NamedElement
import sdu.mdsd.generator.IoTModelUtil
import sdu.mdsd.ioT.Loop
import sdu.mdsd.generator.IoTInheritanceUtil
import sdu.mdsd.ioT.VarOrList
import java.util.HashSet
import sdu.mdsd.ioT.ListenDeclaration

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class IoTValidator extends AbstractIoTValidator {
	
	protected static val ISSUE_CODE_PREFIX =    "sdu.mdsd.iot."
	public static val HIERARCHY_CYCLE =     ISSUE_CODE_PREFIX + "HierarchyCycle";
	
	@Inject extension IoTModelUtil
	@Inject extension IoTInheritanceUtil
	
	@Check def checkClassHierarchy(Device d){
		if (d.classHierarchy.contains(d)){
			switch(d){
				IoTDevice: error("cycle in inheritance of device '" + d.name + "'",  IoTPackage.eINSTANCE.getIoTDevice_Parent(),  HIERARCHY_CYCLE, d.parent.name)
				ControllerDevice: error("cycle in inheritance of device '" + d.name + "'",  IoTPackage.eINSTANCE.getControllerDevice_Parent(),  HIERARCHY_CYCLE, d.parent.name)
			}
			
		}
	}
	
	public static val WRONG_METHOD_OVERRIDE =  ISSUE_CODE_PREFIX + "WrongMethodOverride"
	public static val NO_SUPER_OVERRIDE =  "Override cannot be used as this device does not inherit from an abstract device."	
	
	@Check def checkLegalOverrides(Loop loop) {
		val d = getContainingDevice(loop)
		val parent = d.getParentDevice
		// Check if the parent has a loop with the same name
		if (parent === null && loop.getOverride !== null) {
			error(
				NO_SUPER_OVERRIDE,
				IoTPackage.eINSTANCE.namedElement_Name,
				WRONG_METHOD_OVERRIDE
			)
		}
		if (parent !== null) {
			if (!parent.program.loops.map[name].toList.contains(loop.name) && loop.getOverride !== null) {
				error(
					"Super does not implement loop '" + loop.name + "'",
					IoTPackage.eINSTANCE.namedElement_Name,
					WRONG_METHOD_OVERRIDE
				)

			}
			if (parent.program.loops.map[name].toList.contains(loop.name) && loop.getOverride === null) {
				error("Super implements loop with same name as '" + loop.name + "'. Use override keyword.",
					IoTPackage.eINSTANCE.namedElement_Name, WRONG_METHOD_OVERRIDE)
			}
		}

	}
	
	@Check def checkLegalListenOverride(ListenDeclaration listen){
		val d = getContainingDevice(listen)
		val parent = d.getParentDevice
		
		if (parent === null){
			if (listen.override !== null)
				error(NO_SUPER_OVERRIDE, listen, IoTPackage.eINSTANCE.listenDeclaration_Ip, WRONG_METHOD_OVERRIDE)
		} else if (parent.program.listenDeclaration !== null && listen.override === null){
			error("Super already implements a listen declaration. Override using 'override' keyword",
				listen, IoTPackage.eINSTANCE.listenDeclaration_Ip, WRONG_METHOD_OVERRIDE)
		} else if (parent.program.listenDeclaration === null && listen.override !== null){
			error("Override cannot be used, as super does not implement a listen declaration",listen, IoTPackage.eINSTANCE.listenDeclaration_Ip, WRONG_METHOD_OVERRIDE)
		}
	}
	
	@Check def duplicateNameForInheritedVariables(VarOrList v) {
		val d = getContainingDevice(v)
		val parent = d.getParentDevice

		if (parent !== null) {
			if (parent.program.variables.map[name].toList.contains(v.name)) {
				error("Super already implements a variable named '" + v.name + "'.",
					IoTPackage.eINSTANCE.namedElement_Name, DUPLICATE_ELEMENT)
			}
		}
	}


	@Check def void checkNoDuplicateExternals(Model m){
		val eSet = new HashSet<String>();
		for (ext : m.externalDeclarations){
			if (eSet.contains(ext.name))
				error("External '" + ext.name + "' has already been declared.", ext, IoTPackage.eINSTANCE.namedElement_Name, DUPLICATE_ELEMENT)
			else {
				eSet.add(ext.name);
			}
		}
	}


	public static val UNUSED_ELEMENT = ISSUE_CODE_PREFIX + "UnusedElement"
	

	
	@Check def void checkNoDuplicateVariables(Program p){
		checkNoDuplicateElements(p.connectDeclarations, "variables")
		checkNoDuplicateElements(p.variables, "connect statements")
		checkNoDuplicateElements(p.loops, "loops")
	}
	
	@Check def void checkNoDuplicateDeclarations(Model m){
		checkNoDuplicateElements(m.devices, "devices")
		checkNoDuplicateElements(m.configs, "configs")
	}

	
	//Check duplicate inherited element
	
	public static val DUPLICATE_ELEMENT = ISSUE_CODE_PREFIX + "DuplicateElement"
	
	def private void checkNoDuplicateElements(Iterable<? extends NamedElement> elements, String desc) {
		val multiMap = HashMultimap.create()
		
		for (e : elements)
			multiMap.put(e.name, e)
			
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					error(
						"Duplicate " + desc + " '" + d.name + "'", d, IoTPackage.eINSTANCE.namedElement_Name, DUPLICATE_ELEMENT
					)
			}
		}
	}
		
}
